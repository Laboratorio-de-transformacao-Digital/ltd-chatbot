import { AssistantMessage, DataMessage, FunctionCall, JSONValue, ToolCall } from './types';
type StreamString = `${(typeof StreamStringPrefixes)[keyof typeof StreamStringPrefixes]}:${string}\n`;
export interface StreamPart<CODE extends string, NAME extends string, TYPE> {
    code: CODE;
    name: NAME;
    parse: (value: JSONValue) => {
        type: NAME;
        value: TYPE;
    };
}
declare const textStreamPart: StreamPart<'0', 'text', string>;
declare const functionCallStreamPart: StreamPart<'1', 'function_call', {
    function_call: FunctionCall;
}>;
declare const dataStreamPart: StreamPart<'2', 'data', Array<JSONValue>>;
declare const errorStreamPart: StreamPart<'3', 'error', string>;
declare const assistantMessageStreamPart: StreamPart<'4', 'assistant_message', AssistantMessage>;
declare const assistantControlDataStreamPart: StreamPart<'5', 'assistant_control_data', {
    threadId: string;
    messageId: string;
}>;
declare const dataMessageStreamPart: StreamPart<'6', 'data_message', DataMessage>;
declare const toolCallStreamPart: StreamPart<'7', 'tool_calls', {
    tool_calls: ToolCall[];
}>;
declare const messageAnnotationsStreamPart: StreamPart<'8', 'message_annotations', Array<JSONValue>>;
type StreamParts = typeof textStreamPart | typeof functionCallStreamPart | typeof dataStreamPart | typeof errorStreamPart | typeof assistantMessageStreamPart | typeof assistantControlDataStreamPart | typeof dataMessageStreamPart | typeof toolCallStreamPart | typeof messageAnnotationsStreamPart;
/**
 * Maps the type of a stream part to its value type.
 */
type StreamPartValueType = {
    [P in StreamParts as P['name']]: ReturnType<P['parse']>['value'];
};
export type StreamPartType = ReturnType<typeof textStreamPart.parse> | ReturnType<typeof functionCallStreamPart.parse> | ReturnType<typeof dataStreamPart.parse> | ReturnType<typeof errorStreamPart.parse> | ReturnType<typeof assistantMessageStreamPart.parse> | ReturnType<typeof assistantControlDataStreamPart.parse> | ReturnType<typeof dataMessageStreamPart.parse> | ReturnType<typeof toolCallStreamPart.parse> | ReturnType<typeof messageAnnotationsStreamPart.parse>;
export declare const streamPartsByCode: {
    readonly "0": StreamPart<"0", "text", string>;
    readonly "1": StreamPart<"1", "function_call", {
        function_call: FunctionCall;
    }>;
    readonly "2": StreamPart<"2", "data", JSONValue[]>;
    readonly "3": StreamPart<"3", "error", string>;
    readonly "4": StreamPart<"4", "assistant_message", AssistantMessage>;
    readonly "5": StreamPart<"5", "assistant_control_data", {
        threadId: string;
        messageId: string;
    }>;
    readonly "6": StreamPart<"6", "data_message", DataMessage>;
    readonly "7": StreamPart<"7", "tool_calls", {
        tool_calls: ToolCall[];
    }>;
    readonly "8": StreamPart<"8", "message_annotations", JSONValue[]>;
};
/**
 * The map of prefixes for data in the stream
 *
 * - 0: Text from the LLM response
 * - 1: (OpenAI) function_call responses
 * - 2: custom JSON added by the user using `Data`
 * - 6: (OpenAI) tool_call responses
 *
 * Example:
 * ```
 * 0:Vercel
 * 0:'s
 * 0: AI
 * 0: AI
 * 0: SDK
 * 0: is great
 * 0:!
 * 2: { "someJson": "value" }
 * 1: {"function_call": {"name": "get_current_weather", "arguments": "{\\n\\"location\\": \\"Charlottesville, Virginia\\",\\n\\"format\\": \\"celsius\\"\\n}"}}
 * 6: {"tool_call": {"id": "tool_0", "type": "function", "function": {"name": "get_current_weather", "arguments": "{\\n\\"location\\": \\"Charlottesville, Virginia\\",\\n\\"format\\": \\"celsius\\"\\n}"}}}
 *```
 */
export declare const StreamStringPrefixes: {
    readonly text: "0";
    readonly function_call: "1";
    readonly data: "2";
    readonly error: "3";
    readonly assistant_message: "4";
    readonly assistant_control_data: "5";
    readonly data_message: "6";
    readonly tool_calls: "7";
    readonly message_annotations: "8";
};
export declare const validCodes: ("0" | "2" | "6" | "1" | "3" | "4" | "5" | "7" | "8")[];
/**
Parses a stream part from a string.

@param line The string to parse.
@returns The parsed stream part.
@throws An error if the string cannot be parsed.
 */
export declare const parseStreamPart: (line: string) => StreamPartType;
/**
Prepends a string with a prefix from the `StreamChunkPrefixes`, JSON-ifies it,
and appends a new line.

It ensures type-safety for the part type and value.
 */
export declare function formatStreamPart<T extends keyof StreamPartValueType>(type: T, value: StreamPartValueType[T]): StreamString;
export {};
//# sourceMappingURL=streamParts.d.ts.map